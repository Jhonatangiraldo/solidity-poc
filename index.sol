pragma solidity >=0.5.0 <0.6.0;

contract ZombieFactory {
    uint256 dnaDigits = 16;
    uint256 dnaModulus = 10**dnaDigits;

    /**
        using event keyword seems like it makes the event(event name ) 
        to inherit from an event prototype. I think this because i just need to type
        the 'emit' keyword with the event name and it just fires the event.
        As if the event(referenced by the event name) was already an sort of 
        Event instance created
    */
    // events are written like writting a function type, its parameters types
    // events are written with capital first letter, like an interface or type
    event NewZombie(uint256 zombieId, string name, uint256 dna);

    // class is like struct
    struct Zombie {
        // types are before the variable name
        string name;
        uint256 dna;
    }

    // don't need to initialize elements, they seem to be initialized with just the type
    Zombie[] public zombies;

    // memory is a copmile space, it's dynamic and it's cleared once the contract run finishes
    // https://stackoverflow.com/a/33839164/7044942
    function createZombie(string memory _name, uint256 _dna) public {
        /**
          1. to create structs it doesn't need to word new 
          2. structs creation doesn't need the structs definitions to have a constructor, 
              it saves the params in the order they are provided as the properties 
              in the order they are been written      
       */
        uint256 id = zombies.push(Zombie(_name, _dna)) - 1;
        /** JS should be like:
            YourContract.IntegersAdded(function(error, result) {
                do something with result
            })
        */
        emit NewZombie(id, _name, _dna);
    }

    // underscore(_) go before the name as a convention for private vars/functions and functions paramters
    function _createZombie(string memory _name, uint256 _dna) private {
        zombies.push(Zombie(_name, _dna));
    }

    //view function, meaning it's only viewing the data but not modifying it:
    // returns and parentheses with the type of data
    function sayHello() public view returns (string memory) {}

    //pure functions, which means you're not even accessing any data in the app
    function _multiply(uint256 a, uint256 b) private pure returns (uint256) {
        return a * b;
    }

    // example combining a couple of keywords
    function _generateRandomDna(string memory _str)
        private
        view
        returns (uint256)
    {}

    /**
        It is very similar to API (Application Program Interface), a human-readable representation of a codeâ€™s interface.
        ABI defines the methods and structures used to interact with the binary contract, just like API does but on a lower-level
    */
    // we can type cast using functions similar to parse, like Number(string) then uint256(otherType)
    uint256 rand = uint256(keccak256(abi.encodePacked(_str)));
}



// The browser uses Web3.js to interact with our contract. A similar code like this
// Here's how we would access our contract:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory` has access to our contract's public functions and events

// some sort of event listener to take the text input:
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // Call our contract's `createRandomZombie` function:
  ZombieFactory.createRandomZombie(name)
})

// Listen for the `NewZombie` event, and update the UI
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})
